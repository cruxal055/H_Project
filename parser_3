#include <QCoreApplication>
#include <iostream>
#include <QXmlStreamReader>
#include <map>
#include <QFile>
#include <set>
#include <algorithm>

using namespace std;

#define sSet set<street>

struct range
{
    public:
        QString one, two;
    range()
    {
        one = "";
        two = "";
    }
    range &operator=(const range &other)
    {
        if(this != &other)
        {
            one = other.one;
            two = other.two;
        }
        return *this;
    }
    range(const range &other)
    {
        one = other.one;
        two = other.two;
    }
    friend bool operator<=(const range &o1, const range &o2)
        {
            return o1.two <= o2.two;
        }

        friend bool operator>=(const range &o1 ,const range &o2)
        {
            return o1.two >= o2.two;
        }
        friend bool operator>(const range &o1 ,const range &o2)
        {
            return o1.two > o2.two;
        }
        friend bool operator<(const range &o1 ,const range &o2)
        {
            return o1.two < o2.two;
        }

};

struct coordinates
{
    public:
        QString lattitude, longitude;
        coordinates()
        {
            lattitude = " ";
            longitude = " ";
        }
        coordinates &operator=(const coordinates &other)
        {
            if(this != &other)
            {
                lattitude = other.lattitude;
                longitude = other.longitude;
            }
            return *this;
        }

        coordinates(const coordinates &other)
        {
            lattitude = other.lattitude;
            longitude = other.longitude;
        }

        friend bool operator<=(const coordinates &o1 ,const coordinates &o2)
        {
            return o1.longitude <= o2.longitude;
        }

        friend bool operator>=(const coordinates &o1 ,const coordinates &o2)
        {
            return o1.longitude >= o2.longitude;
        }
        friend bool operator>(const coordinates &o1 ,const coordinates &o2)
        {
            return o1.longitude > o2.longitude;
        }
        friend bool operator<(const coordinates &o1 ,const coordinates &o2)
        {
            return o1.longitude < o2.longitude;
        }
};

class street
{
    public:

        QString fromAddress, toAddress, streetNum, zipCode;
        QString streetName, streetSFX;
        QString direction;
        vector<coordinates> waypoints;
        set<coordinates> hasAlready;


        street()
        {
            fromAddress = toAddress = streetNum = zipCode = "";
            streetName = streetSFX = "";
            direction = "";
        }

        street(const street &other)
        {
            fromAddress = other.fromAddress;
            toAddress = other.toAddress;
            streetNum = other.streetNum;
            zipCode = other.zipCode;
            streetName = other.streetName;
            streetSFX = other.streetSFX;
            direction = other.direction;
            waypoints = other.waypoints;
            hasAlready = other.hasAlready;
        }

        street& operator=(const street &other)
        {
            if(this != &other)
            {
                fromAddress = other.fromAddress;
                toAddress = other.toAddress;
                streetNum = other.streetNum;
                zipCode = other.zipCode;
                streetName = other.streetName;
                streetSFX = other.streetSFX;
                direction = other.direction;
                waypoints = other.waypoints;
               hasAlready = other.hasAlready;
            }
            return *this;
        }
        friend bool operator<=(const street &o1 ,const street &o2)
        {
            return o1.fromAddress <= o2.fromAddress;
        }

        friend bool operator>=(const street &o1 ,const street &o2)
        {
            return o1.fromAddress>= o2.fromAddress;
        }
        friend bool operator>(const street &o1 ,const street &o2)
        {
            return o1.fromAddress > o2.fromAddress;
        }
        friend bool operator<(const street &o1 ,const street &o2)
        {
            return o1.fromAddress < o2.fromAddress;
        }
};


void writeOut(map<QString, sSet> &toOutput)
{
    QFile out;
    QXmlStreamWriter output;
    out.setFileName("sanitized.xml");
    out.open(QIODevice::WriteOnly);
    output.setDevice(&out);
    output.setAutoFormatting(true);
    output.writeStartDocument();
    output.writeStartElement("EAGLE_ROCK");
    for(auto i = toOutput.begin(); i != toOutput.end(); ++i)
    {
       auto temp = toOutput[i->first].begin();
       for(auto j = toOutput[i->first].begin(); j != toOutput[i->first].end(); ++j)
       {    
           output.writeStartElement("STREET");
           output.writeTextElement("FROM_ADDRESS", j.t);
           output.writeTextElement("TO_ADDRESS", i->second.toAddress);
           output.writeTextElement("STREET_NAME", i->second.streetName);
           output.writeTextElement("STREET_NUM", i->second.streetNum);
           output.writeTextElement("STREET_SFX", i->second.streetSFX);
           output.writeTextElement("TDIR", i->second.direction);
           output.writeTextElement("ZIP", i->second.zipCode);
           for(unsigned int j = 0; j < i->second.waypoints.size(); ++j)
           {
               output.writeTextElement("LATTITUDE" , i->second.waypoints[j].lattitude);
               output.writeTextElement("LONGITUDE" , i->second.waypoints[j].longitude);
           }
       }
       output.writeEndElement();
    }
    output.writeEndElement();
    output.writeEndDocument();

}

int main(int argc, char *argv[])
{
    QFile stream;
    stream.setFileName("streets4.xml");
    stream.open(QFile::ReadOnly | QFile::Text);
    map<QString,sSet> master;
    QXmlStreamReader streamer;
    streamer.setDevice(&stream);
    streamer.readNextStartElement();
    streamer.readNextStartElement();
    int counter = 0;
    while(!streamer.atEnd())
    {
      //  cout << "the counter is: " << counter << endl;
        //cout << "------------------------------------- " << counter << endl;
//        if(counter == 100)
//            break;
        string item;
        street temp;
        coordinates grid;

        if(streamer.name() == "STREET" )
        {
      //      cout << "be looking at: " << streamer.name().toString().toStdString() << endl;
            streamer.readNextStartElement();
        //   cout << "-1, be looking at: " << streamer.name().toString().toStdString() << endl;
            temp.fromAddress = streamer.readElementText();


            streamer.readNextStartElement();
          //  cout << "0 " << streamer.name().toString().toStdString() << endl;
            temp.toAddress = streamer.readElementText();

            streamer.readNextStartElement();
            //cout << "1 " << streamer.name().toString().toStdString() << endl;
            temp.streetName = streamer.readElementText();


            streamer.readNextStartElement();
            //cout << "2 " << streamer.name().toString().toStdString() << endl;
            temp.streetNum = streamer.readElementText();

            streamer.readNextStartElement();
            //cout << "3 " << streamer.name().toString().toStdString() << endl;
            if(streamer.name() == "STSFX")
            {
                temp.streetSFX = streamer.readElementText();
                streamer.readNextStartElement();
            }

          //  cout << "4 " << streamer.name().toString().toStdString() << endl;
            temp.direction = streamer.readElementText();


            streamer.readNextStartElement();
          // cout << "5 " << streamer.name().toString().toStdString() << endl;

            temp.zipCode = streamer.readElementText();


            streamer.readNextStartElement();

          //  cout << "before i wash looking at: " << streamer.name().toString().toStdString() << endl;

            while(streamer.name() == "LATITUDE")
            {
                grid.lattitude = streamer.readElementText();


                streamer.readNextStartElement();
                grid.longitude = streamer.readElementText();

                streamer.readNextStartElement();

                temp.hasAlready.insert(grid);
                temp.waypoints.push_back(grid);

            }
            streamer.readNextStartElement();
            cout << "i ended at: " << temp.streetName.toStdString() << endl;
        }
        else
        {
            cout << "WTF BRO?? with: " << streamer.name().toString().toStdString() << endl;
            cout << "the counter is at: " << counter << endl;
            break;
        }
        if(streamer.hasError())
        {
            cout << streamer.errorString().toStdString() << endl;
        }

        if(master.count(temp.fromAddress))
            master[temp.streetName].insert(temp);
    }
    writeOut(master);

    return 0;
}
